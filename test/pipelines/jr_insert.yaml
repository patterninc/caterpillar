tasks:
# Step 1: Get data from Google Sheet including header row for column count
  - name: get_google_drive_file
    type: http
    method: GET
    endpoint: "https://sheets.googleapis.com/v4/spreadsheets/1GUX7kfcUwdODTSUc6QAYl6Uqti0Y0UoHTsvHxz4FI6k?ranges=Keywords!a1:zz999999&fields=sheets(data(rowData(values(userEnteredFormat/numberFormat,userEnteredValue))))"
    headers:
      Content-Type: application/x-www-form-urlencoded
      Accept: text/csv
    oauth:
      version: "2.0"
      issuer: {{ secret "/google_service/issuer" }}
      scope: 
        - "https://www.googleapis.com/auth/drive"
        - "https://www.googleapis.com/auth/spreadsheets"
      audience: "https://oauth2.googleapis.com/token"
      token_uri: "https://oauth2.googleapis.com/token"
      grant_type: "urn:ietf:params:oauth:grant-type:jwt-bearer"
      private_key: {{ secret "/google_service/private_key" }}
# Step 2: Extract column data types from first row
  - name: extract_column_types
    type: jq
    path: |
      {
        "data": .,
        "column_types": [.sheets[].data[].rowData[0].values[] | 
          if .userEnteredFormat.numberFormat.type == "NUMBER" then "int"
          elif .userEnteredFormat.numberFormat.type == "DATE" then "int"
          elif .userEnteredFormat.numberFormat.type == "TIME" then "varchar"
          else "varchar" end]
      }
# Step 3: Extract and format row data, ensuring all rows have the correct number of columns.  Nulls are added to rows with missing columns, allowing for a total of 52 (2 * 26) columns per row.
  - name: extract_rows
    type: jq  
    explode: true
    path: |
      .data.sheets[].data[].rowData as $all_rows |
      .column_types as $types |
      ($all_rows[0].values | length) as $expected_count |
      $all_rows[1:] | map(
        {
          "row_data": ([.values[] | 
            if .userEnteredValue.stringValue then 
              .userEnteredValue.stringValue
            elif .userEnteredValue.boolValue != null then
              (.userEnteredValue.boolValue | tostring)
            elif .userEnteredValue.numberValue then
              if .userEnteredFormat.numberFormat.type == "DATE" then
                (.userEnteredValue.numberValue - 25569) * 86400
              else
                .userEnteredValue.numberValue
              end
            else 
              null
            end
          ] + ([range($expected_count - (.values | length)) | null]))[:$expected_count],
          "column_types": $types
        } |
        select(.row_data | any(. != null))
      )
# Step 4: Replace newline characters with spaces in string values
  - name: replace_newlines_in_strings
    type: jq
    path: |
      .row_data = (.row_data | map(if type == "string" then gsub("\n"; " ") else . end)) | .
# Step 5: Replace tab characters with spaces in string values
  - name: replace_tabs_in_strings
    type: jq
    path: |
      .row_data = (.row_data | map(if type == "string" then gsub("\t"; " ") else . end)) | .
# Step 6: Replace single quotes in string values with two single quotes to prevent SQL errors
  - name: escape_single_quotes
    type: jq
    path: |
      .row_data = (.row_data | map(if type == "string" then (. | gsub("'"; "''")) else . end)) | .
# Step 7: Replace double quotes with escaped double quote
  - name: escape_double_quotes
    type: jq
    path: |
      .row_data = (.row_data | map(if type == "string" then (. | gsub("\""; "\\\"")) else . end)) | .
# Step 8: Format complete rows as SQL VALUES tuples using column types from first row
  - name: format_sql_values
    type: jq
    as_raw: true
    path: |
      "(" + ([.row_data, .column_types] | transpose | map(
        if .[0] == null then "NULL"
        elif .[1] == "varchar" then "'" + (.[0] | tostring) + "'"
        else (.[0] | tostring)
        end
      ) | join(",")) + ")"
# Step 9: Batch VALUES into groups controlled by the {records_per_insert} parameter and create separate INSERT statements
  - name: batch_and_create_inserts
    type: join
    number: 1 # Batch size for records per INSERT
    size: 2097152 # 2MB max size per batch in bytes
    delimiter: ", "
# Step 10: Clean up any newlines introduced by join operation
  - name: cleanup_join_newlines
    type: replace
    expression: "\n"
    replacement: " "
# Step 11: Add SQL INSERT header and wrap in JSON for each batch
  - name: create_json_query
    type: replace
    expression: "^"
    replacement: "{\"query\":\"INSERT INTO adhoc.global_keyword_list_jr2 VALUES "
# Step 12: Close JSON structure  
  - name: close_json
    type: replace
    expression: "$"
    replacement: "\"}"
# Step 13: Execute the SQL using Heimdall
  - name: insert_into_table_heimdall
    type: heimdall
    endpoint: http://localhost:9090 #http://heimdall.prod.pattern.aws.internal
    # headers:
    #   X-Pattern-Service: __SECRET_TOKEN__
    job:
      command_criteria:
        - type:trino
      cluster_criteria:
        - data:prod
    fail_on_error: true
    poll_interval: 1s